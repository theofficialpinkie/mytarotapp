<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Preparing Your Reading</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preload" as="font" href="/assets/fonts/BookmanJFPro-Regular.woff" type="font/woff" crossorigin>

  <style>
    @font-face {
      font-family: 'Bookman JF Pro';
      src: url('/assets/fonts/BookmanJFPro-Regular.woff') format('woff');
      font-weight: normal; font-style: normal; font-display: swap;
    }

    :root {
      /* Colors tuned for calm */
      --bg1: #0d0f1a;
      --bg2: #151a2b;
      --bg3: #1a1330;
      --ring: rgba(255,255,255,.18);
      --ring-strong: rgba(255,255,255,.35);
      --panel: rgba(255,255,255,.06);
      --panel-border: rgba(255,255,255,.12);
      --text: #fff;
      --muted: rgba(255,255,255,.75);

      /* Timing */
      --breath: 6s;         /* inhale + exhale cycle */
      --fade: .75s;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      font-family: 'Bookman JF Pro', serif;
      color: var(--text);
      background:
        radial-gradient(1200px 800px at 25% 20%, rgba(147,51,234,.08), transparent 55%),
        radial-gradient(1000px 700px at 75% 85%, rgba(59,130,246,.08), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow: hidden;
      animation: bg-shift 32s ease-in-out infinite alternate;
    }

    /* Very slow, subtle background shift */
    @keyframes bg-shift {
      0%   { background-position: 0% 0%, 0% 0%, 0% 0%; }
      100% { background-position: 5% 2%, -3% -4%, 0% 100%; }
    }

    /* Full-screen ritual container */
    .ritual {
      position: fixed;
      inset: 0;
      z-index: 99999;
      display: grid;
      place-items: center;
      padding: clamp(16px, 4vw, 40px);
      isolation: isolate;
    }

    /* Breathing circle */
    .breath {
      position: absolute;
      width: min(60vmin, 520px);
      aspect-ratio: 1/1;
      border-radius: 50%;
      display: grid;
      place-items: center;
      filter: drop-shadow(0 10px 40px rgba(0,0,0,.45));
      animation: breathe var(--breath) ease-in-out infinite;
    }

    /* Soft ring & inner glow */
    .breath::before,
    .breath::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 50%;
    }

    /* Outer ring with subtle gradient edge */
    .breath::before {
      background:
        radial-gradient(closest-side, transparent 68%, var(--ring) 72%, transparent 76%),
        radial-gradient(closest-side, rgba(147,51,234,.12), transparent 75%);
      filter: blur(.3px);
    }

    /* Inner core with tender glow */
    .breath::after {
      margin: 10%;
      background:
        radial-gradient(circle at 50% 45%, rgba(255,255,255,.18), rgba(255,255,255,.06) 45%, transparent 70%);
      box-shadow:
        0 0 50px 18px rgba(147,51,234,.12),
        inset 0 0 60px rgba(255,255,255,.08);
    }

    /* Inhale (grow/brighten) → exhale (shrink/soften) */
    @keyframes breathe {
      0%   { transform: scale(0.92); opacity: .9; }
      50%  { transform: scale(1.04); opacity: 1; }
      100% { transform: scale(0.92); opacity: .9; }
    }

    /* Message panel */
    .panel {
      position: relative;
      z-index: 2;
      width: min(900px, 92vw);
      display: grid;
      place-items: center;
      gap: 16px;
      padding: clamp(18px, 4vw, 36px);
      border-radius: 24px;
      backdrop-filter: blur(10px) saturate(120%);
      -webkit-backdrop-filter: blur(10px) saturate(120%);
      background: var(--panel);
      border: 1px solid var(--panel-border);
    }

    .title {
      font-size: clamp(24px, 5vw, 48px);
      line-height: 1.2;
      letter-spacing: .2px;
      text-align: center;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity var(--fade) ease, transform var(--fade) ease;
      text-shadow: 0 1px 18px rgba(107,70,193,.35);
    }
    .title.show { opacity: 1; transform: translateY(0); }

    .hint {
      font-size: clamp(13px, 2.2vw, 18px);
      color: var(--muted);
      opacity: .85;
      text-align: center;
    }

    .progress {
      margin-top: 4px;
      font-size: clamp(11px, 2vw, 14px);
      color: rgba(255,255,255,.6);
      letter-spacing: .35px;
      user-select: none;
      text-align: center;
    }

    /* Pulse helper for the hint line (very gentle) */
    .pulse { animation: hintpulse 2.2s ease-in-out infinite; }
    @keyframes hintpulse { 0%{opacity:.6} 50%{opacity:1} 100%{opacity:.6} }

    /* Accessibility: honor reduced motion */
    @media (prefers-reduced-motion: reduce) {
      body { animation: none; }
      .breath { animation: none; }
      .pulse { animation: none; }
      .title { transition: none; }
    }
  </style>
</head>
<body>
  <div class="ritual" id="ritual" aria-live="polite">
    <div class="breath" aria-hidden="true"></div>

    <div class="panel" role="status" aria-atomic="true">
      <div class="title" id="msg">Focus on your question</div>
      <div class="hint pulse" id="hint">We’re preparing your deck…</div>
      <div class="progress" id="progress">1 / 3</div>
    </div>
  </div>

  <script>
    // ---------- Tunables ----------
    const MESSAGES = [
      "Focus on your question",
      "Say it out loud or in your head",
      "Fetching your cards…"
    ];
    const FETCH_AT_INDEX = 2;          // 0-based -> third message
    const PER_MESSAGE_MS = 3800;       // dwell per message
    const MIN_TOTAL_MS    = 12000;     // minimum overall ritual duration
    const FETCH_TIMEOUT   = 35000;     // initial fetch timeout
    const FETCH_HARDCAP   = 90000;     // absolute cap

    const $msg = document.getElementById('msg');
    const $hint = document.getElementById('hint');
    const $progress = document.getElementById('progress');

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    function fetchWithTimeout(resource, { timeout, hardCap, ...opts } = {}) {
      const ctrl = new AbortController();
      const timer = setTimeout(() => ctrl.abort(), timeout || 25000);
      const cap   = hardCap ? setTimeout(() => ctrl.abort(), hardCap) : null;
      return fetch(resource, { ...opts, signal: ctrl.signal })
        .finally(() => { clearTimeout(timer); if (cap) clearTimeout(cap); });
    }

    async function getSpread() {
      const tryOnce = (timeoutMs) => fetchWithTimeout('/api/spread', {
        timeout: timeoutMs, hardCap: FETCH_HARDCAP, cache: 'no-store'
      });

      try {
        const res = await tryOnce(FETCH_TIMEOUT);
        if (!res.ok) throw new Error('spread ' + res.status);
        const data = await res.json();
        sessionStorage.setItem('spread', JSON.stringify(data.spread || []));
        return data;
      } catch (e1) {
        await sleep(600);
        try {
          const res2 = await tryOnce(Math.max(FETCH_TIMEOUT * 1.6, 52000));
          if (!res2.ok) throw new Error('spread retry ' + res2.status);
          const data2 = await res2.json();
          sessionStorage.setItem('spread', JSON.stringify(data2.spread || []));
          return data2;
        } catch (e2) {
          console.error('❌ Error fetching spread:', e2);
          $hint.textContent = "Network is a bit slow… we’ll finish preparing in the next screen.";
          $hint.classList.remove('pulse');
          throw e2;
        }
      }
    }

    async function runSequence() {
      const started = Date.now();
      let fetchPromise = null;

      for (let i = 0; i < MESSAGES.length; i++) {
        // Swap line with a soft fade
        $msg.classList.remove('show');
        await sleep(120);
        $msg.textContent = MESSAGES[i];
        $progress.textContent = `${i + 1} / ${MESSAGES.length}`;
        requestAnimationFrame(() => $msg.classList.add('show'));

        // Start backend fetching/shuffling exactly on the third line
        if (i === FETCH_AT_INDEX && !fetchPromise) {
          $hint.textContent = "Shuffling your deck…";
          fetchPromise = getSpread().catch(() => null); // don’t hard-block UX on failure
        }

        await sleep(PER_MESSAGE_MS);
      }

      // Ensure the ritual lasts at least MIN_TOTAL_MS
      const elapsed = Date.now() - started;
      if (elapsed < MIN_TOTAL_MS) await sleep(MIN_TOTAL_MS - elapsed);

      try { if (fetchPromise) await fetchPromise; } catch (_) {}

      // Fade out → go to spread
      const $ritual = document.getElementById('ritual');
      $ritual.style.transition = 'opacity .6s ease';
      $ritual.style.opacity = '0';
      setTimeout(() => { window.location.href = '/spread.html'; }, 620);
    }

    document.addEventListener('DOMContentLoaded', () => {
      requestAnimationFrame(runSequence);
    });
  </script>
</body>
</html>
