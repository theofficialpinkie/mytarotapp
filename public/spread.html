<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Your Reading with Erika</title>

  <link rel="stylesheet" href="/shared-styles.css" />
  <link rel="stylesheet" href="/mobile-overrides.css?v=3" />


  <script>
    // Insert top bar
    document.addEventListener('DOMContentLoaded', function () {
      document.body.insertAdjacentHTML(
        'afterbegin',
        `
        <div class="top-bar">
          <div class="logo-wrap">
            <img src="/assets/tapp-logo.png" class="tapp-logo" alt="Tapp Logo">
            <span class="byline">by Erika Owls</span>
          </div>
          <a href="https://erikaowlsspiritualmentor.as.me/schedule/e19f47fc" target="_blank" class="booking-button">
            Book a 1-1 Psychic Session
          </a>
        </div>
      `
      );
      document.body.classList.add('has-top-bar');
    });

    // ðŸ”’ Safety: ensure .layout wrapper exists with (deck, chat) inside in the right order
    document.addEventListener('DOMContentLoaded', () => {
      const content = document.getElementById('contentPanel');   // deck
      const chat = document.querySelector('.chat-panel');        // chat

      if (!content || !chat) return;

      const sameParent = content.parentElement === chat.parentElement;
      const alreadyLayout = sameParent && content.parentElement.classList.contains('layout');

      if (!alreadyLayout) {
        const layout = document.createElement('main');
        layout.className = 'layout';
        // insert wrapper before whichever of the two appears first
        const first = (content.compareDocumentPosition(chat) & Node.DOCUMENT_POSITION_FOLLOWING) ? content : chat;
        first.parentNode.insertBefore(layout, first);
        layout.appendChild(content);
        layout.appendChild(chat);
      }
    });
  </script>

  <style>
    @font-face {
      font-family: 'Bookman JF Pro';
      src: url('/assets/fonts/BookmanJFPro-Regular.woff2') format('woff2'),
           url('/assets/fonts/BookmanJFPro-Regular.woff') format('woff');
      font-weight: normal;
      font-style: normal;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    /* Keep body simple; layout handled by .layout */
    body {
      background: black;
      color: white;
      font-family: 'Bookman JF Pro', serif;
      display: block;              /* important: not a flex container */
      padding-top: 80px;           /* room for fixed top bar */
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* === Desktop Grid: chat | deck === */
    .layout {
      display: grid;
      grid-template-columns: 45% 55%;
      grid-template-areas: "chat deck";
      min-height: calc(100vh - 80px);
    }
    .chat-panel   { grid-area: chat; }
    .content-panel{ grid-area: deck; }

    /* Chat panel visuals */
    .chat-panel {
      padding: 20px 40px;
      display: flex;
      flex-direction: column;
      background: linear-gradient(145deg, #0a0a0a 0%, #1a1a1a 100%);
      border-right: 1px solid rgba(255,255,255,0.1);
      position: relative;
      min-height: calc(100vh - 80px);
    }
    .chat-header { display:flex; align-items:center; gap:15px; padding:20px 0; border-bottom:1px solid rgba(255,255,255,0.08); margin-bottom:20px; }
    .erika-avatar { width:50px; height:50px; border-radius:50%; border:2px solid rgba(255,255,255,0.1); object-fit:cover; }
    .erika-info h2 { color:#fff; font-weight:600; font-size:18px; margin-bottom:2px; }
    .erika-info p { color:rgba(255,255,255,0.6); font-size:12px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    .chat-messages { flex:none; min-height:400px; max-height:calc(100vh - 200px); display:flex; flex-direction:column; gap:20px; overflow-y:auto; padding-bottom:20px; scroll-behavior:smooth; }
    .message-wrapper { display:flex; align-items:flex-start; gap:12px; opacity:0; transform:translateY(20px); transition:opacity .5s, transform .5s; }
    .message-wrapper.visible { opacity:1; transform:translateY(0); }
    .message-avatar { width:40px; height:40px; border-radius:50%; flex-shrink:0; border:1px solid rgba(255,255,255,0.1); object-fit:cover; }
    .message-content { background: linear-gradient(145deg, rgba(255,255,255,0.04), rgba(255,255,255,0.08)); border:1px solid rgba(255,255,255,0.06); border-radius:18px; padding:16px 20px; color:#fff; font-size:15px; line-height:1.6; max-width:85%; backdrop-filter: blur(10px); box-shadow:0 4px 20px rgba(0,0,0,0.1); }
    .chat-button { background: linear-gradient(135deg, #6b46c1, #9333ea); color:#fff; border:none; padding:12px 24px; border-radius:20px; font-size:14px; font-weight:600; cursor:pointer; transition:all .3s; margin-top:15px; align-self:flex-start; box-shadow:0 4px 15px rgba(107,70,193,0.3); }
    .chat-button:hover { transform:translateY(-2px); box-shadow:0 6px 20px rgba(107,70,193,0.4); }
    .chat-button:disabled { opacity:.5; cursor:not-allowed; transform:none; }

    .chat-overlay { position:absolute; inset:0; background:rgba(0,0,0,0.85); backdrop-filter: blur(5px); display:none; flex-direction:column; justify-content:center; align-items:center; z-index:100; }
    .chat-overlay.active { display:flex; }
    .overlay-title { font-size:24px; color:#fff; margin-bottom:30px; text-align:center; }
    .overlay-buttons { display:flex; flex-direction:column; gap:15px; align-items:center; }
    .overlay-button { background: linear-gradient(135deg, #6b46c1, #9333ea); color:#fff; border:none; padding:15px 30px; border-radius:25px; font-size:16px; font-weight:600; cursor:pointer; min-width:200px; box-shadow:0 4px 15px rgba(107,70,193,.3); }
    .overlay-button.secondary { background: linear-gradient(135deg, rgba(255,255,255,.1), rgba(255,255,255,.2)); border:1px solid rgba(255,255,255,.3); }

    /* Deck area */
    .content-panel {
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      min-height: calc(100vh - 80px);
      padding:20px;
      position:relative;
    }

    /* Shuffle / Loading / Selection / Carousel (unchanged from your version) */
    .shuffle-container { display:none; flex-direction:column; align-items:center; justify-content:flex-start; gap:0; width:100%; height:100%; padding-top:120px; }
    .shuffle-container.active { display:flex; }
    .card-stack { position:relative; width:180px; height:260px; transition: transform .8s cubic-bezier(0.68,-0.55,0.265,1.55); }
    .stack-card { position:absolute; width:180px; height:260px; border-radius:12px; background-image:url('/assets/backs/card-back.png'); background-size:cover; background-position:center; background-color:#333; box-shadow:0 8px 25px rgba(0,0,0,0.4); }

    .loading-container { display:none; flex-direction:column; justify-content:flex-start; align-items:center; text-align:center; gap:0; width:100%; height:100%; padding-top:150px; }
    .loading-container.active { display:flex; }
    .loading-title { font-size:36px; color:#fff; margin-bottom:30px; opacity:1; transition: opacity 1s; }
    .loading-title.hidden { opacity:0; }
    .loading-subtitle { font-size:20px; color:rgba(255,255,255,0.7); opacity:0; transition: opacity .6s; animation:pulse 1.5s infinite ease-in-out; }
    .loading-subtitle.visible { opacity:.7; }
    @keyframes pulse { 0%{opacity:.4} 50%{opacity:1} 100%{opacity:.4} }

    .card-selection-container { display:none; flex-direction:column; justify-content:center; align-items:center; gap:20px; width:100%; }
    .card-selection-container.active { display:flex; }
    .selection-title { font-size:24px; color:#fff; margin-bottom:20px; text-align:center; }
    .card-row { position:relative; width:100%; height:300px; display:flex; justify-content:center; align-items:center; margin-bottom:20px; }
    .card { width:120px; height:180px; border-radius:8px; box-shadow:0 4px 15px rgba(0,0,0,0.6); position:absolute; transform-origin:bottom center; transition: transform .3s, box-shadow .3s; cursor:pointer; transform-style:preserve-3d; perspective:1000px; }
    .card.selected { box-shadow:0 0 25px 8px rgba(255,255,255,0.6); }
    .card-inner { position:relative; width:100%; height:100%; transform-style:preserve-3d; transition: transform .6s; }
    .card-face { position:absolute; inset:0; backface-visibility:hidden; border-radius:6px; background-size:cover; background-position:center; }
    .card-back { background-image:url('/assets/backs/card-back.png'); }
    .card-front { background-image: var(--card-image); transform: rotateY(180deg); }
    .card:not(.selected) .card-inner { transform: rotateY(0deg); }
    .card.selected .card-inner { transform: rotateY(180deg); }
    .selection-progress { text-align:center; color:rgba(255,255,255,0.8); font-size:14px; margin-top:20px; }

    .popup-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.8); display:none; justify-content:center; align-items:center; z-index:1000; backdrop-filter: blur(5px); }
    .popup-overlay.active { display:flex; }
    .popup-container { position:relative; width:500px; height:600px; border-radius:20px; overflow:hidden; box-shadow:0 20px 60px rgba(0,0,0,0.5); border:1px solid rgba(255,255,255,0.1); }
    .popup-video-bg { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; z-index:1; }
    .popup-content { position:relative; z-index:2; width:100%; height:100%; background: linear-gradient(45deg, rgba(0,0,0,0.7) 0%, rgba(107,70,193,0.3) 50%, rgba(0,0,0,0.8) 100%); display:flex; flex-direction:column; justify-content:center; align-items:center; text-align:center; padding:40px; }
    .popup-title { font-size:32px; color:#fff; margin-bottom:20px; text-shadow:2px 2px 4px rgba(0,0,0,0.5); }
    .popup-subtitle { font-size:18px; color:rgba(255,255,255,0.9); margin-bottom:40px; text-shadow:1px 1px 2px rgba(0,0,0,0.5); }
    .popup-loading { display:flex; align-items:center; gap:15px; color:rgba(255,255,255,0.8); font-size:16px; }
    .popup-spinner { width:24px; height:24px; border:2px solid rgba(255,255,255,0.3); border-top:2px solid #fff; border-radius:50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .card-carousel-container { display:none; flex-direction:column; justify-content:center; align-items:center; width:100%; height:100%; padding:40px 20px; }
    .card-carousel-container.active { display:flex; }
    .carousel-title { font-size:28px; color:#fff; margin-bottom:40px; text-align:center; }
    .carousel-wrapper { position:relative; width:100%; max-width:600px; height:350px; display:flex; align-items:center; justify-content:center; }
    .carousel-cards { position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
    .carousel-card { position:absolute; width:200px; height:300px; border-radius:12px; background-size:cover; background-position:center; box-shadow:0 10px 30px rgba(0,0,0,0.6); transition: all .8s cubic-bezier(0.25,0.46,0.45,0.94); cursor:pointer; }
    .carousel-card.active { z-index:10; transform: scale(1.1); box-shadow:0 20px 40px rgba(255,255,255,0.1); }
    .carousel-card.prev { z-index:5; transform: translateX(-180px) scale(0.85) rotateY(15deg); opacity:.7; }
    .carousel-card.next { z-index:5; transform: translateX(180px) scale(0.85) rotateY(-15deg); opacity:.7; }
    .carousel-card.hidden { z-index:1; opacity:.3; transform: scale(0.6); }

    .carousel-nav { display:flex; gap:10px; margin-top:30px; }
    .nav-dot { width:12px; height:12px; border-radius:50%; background:rgba(255,255,255,0.3); cursor:pointer; transition:all .3s; }
    .nav-dot.active { background:#fff; transform: scale(1.2); }

    .carousel-arrow {
      position:absolute; top:50%; transform:translateY(-50%);
      width:44px; height:44px; border-radius:50%; z-index:20;
      border:1px solid rgba(255,255,255,0.5);
      background: rgba(255,255,255,0.08);
      color:#fff; font-size:22px; line-height:1; cursor:pointer;
      backdrop-filter: blur(6px);
      display:grid; place-items:center;
      transition: transform .15s, background .2s, box-shadow .2s;
    }
    .carousel-arrow:hover { transform: translateY(-50%) translateY(-1px); background: rgba(255,255,255,0.14); }
    .carousel-arrow.prev { left:8px; }
    .carousel-arrow.next { right:8px; }
  </style>
</head>
<body>
  <!-- Popup -->
  <div class="popup-overlay" id="popupOverlay">
    <div class="popup-container">
      <video class="popup-video-bg" autoplay muted loop>
        <source src="/assets/background.mp4" type="video/mp4" />
      </video>
      <div class="popup-content">
        <div class="popup-title">Channeling Your Energy</div>
        <div class="popup-subtitle">The cards are revealing their wisdom...</div>
        <div class="popup-loading">
          <div class="popup-spinner"></div>
          <span>Generating your reading</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Panels (order doesnâ€™t matter; wrapper script will fix it if needed) -->
  <div class="chat-panel">
    <div class="chat-overlay" id="chatOverlay">
      <div class="overlay-title">What would you like to do next?</div>
      <div class="overlay-buttons">
        <button class="overlay-button" onclick="hideOverlay()">Read Again</button>
        <button class="overlay-button secondary" onclick="window.location.href='question-screen.html'">Ask Another Question</button>
        <button class="overlay-button secondary" onclick="window.location.href='https://erikaowlsspiritualmentor.as.me/schedule/e19f47fc'" target="_blank">Book 1-1 Session</button>
      </div>
    </div>
    <div class="chat-header">
      <img src="/assets/erika-avatar.png" alt="Erika Owls" class="erika-avatar" onerror="this.style.display='none'" />
      <div class="erika-info">
        <h2>Erika Owls</h2>
        <p>Spiritual Mentor & Tarot Reader</p>
      </div>
    </div>
    <div class="chat-messages" id="chatMessages"></div>
  </div>

  <div class="content-panel" id="contentPanel">
    <div class="shuffle-container" id="shuffleContainer">
      <div class="card-stack" id="cardStack">
        <div class="stack-card"></div><div class="stack-card"></div><div class="stack-card"></div><div class="stack-card"></div>
        <div class="stack-card"></div><div class="stack-card"></div><div class="stack-card"></div><div class="stack-card"></div>
      </div>
    </div>

    <div class="loading-container" id="loadingContainer">
      <div class="loading-title" id="loadingTitle">Take a deep breathâ€¦</div>
      <div class="loading-subtitle" id="loadingSubtitle">Fetching your spread âœ¦</div>
    </div>

    <div class="card-selection-container" id="cardSelectionContainer">
      <div class="card-row" id="row1"></div>
      <div class="card-row" id="row2"></div>
      <div class="selection-progress" id="selectionProgress">Select 6 cards (0 selected)</div>
    </div>

    <div class="card-carousel-container" id="cardCarouselContainer">
      <div class="carousel-title">Your Selected Cards</div>
      <div class="carousel-wrapper">
        <div class="carousel-cards" id="carouselCards"></div>
        <button class="carousel-arrow prev" aria-label="Previous card">â€¹</button>
        <button class="carousel-arrow next" aria-label="Next card">â€º</button>
      </div>
      <div class="carousel-nav" id="carouselNav"></div>
    </div>
  </div>

  <!-- Your original JS (unchanged) -->
  <script>
    let currentPhase = 0;
    let spreadCards = [];
    let selectedCards = [];
    let currentCardIndex = 0;
    let userQuestion = sessionStorage.getItem('userQuestion') || 'What guidance do I need right now?';
    let overlayTimer = null;

    const chatMessages = document.getElementById('chatMessages');
    const shuffleContainer = document.getElementById('shuffleContainer');
    const loadingContainer = document.getElementById('loadingContainer');
    const cardSelectionContainer = document.getElementById('cardSelectionContainer');
    const cardCarouselContainer = document.getElementById('cardCarouselContainer');
    const popupOverlay = document.getElementById('popupOverlay');
    const chatOverlay = document.getElementById('chatOverlay');
    const cardStack = document.getElementById('cardStack');

    function init() {
      addMessage(`Welcome! I can feel your energy around the question: "${userQuestion}"`);
      setTimeout(() => {
        addMessage('Take a moment to set your intention and focus on your question.');
        addStandaloneButton('Shuffle Cards', startShuffle);
        showPhase('shuffle');
      }, 800);
    }

    let isReadingPhase = false;

    function addMessage(text) {
      const messageWrapper = document.createElement('div');
      messageWrapper.className = 'message-wrapper';

      const messageAvatar = document.createElement('img');
      messageAvatar.src = '/assets/erika-avatar.png';
      messageAvatar.className = 'message-avatar';
      messageAvatar.onerror = function () {
        const fallback = document.createElement('div');
        fallback.style.cssText = `
          width: 40px; height: 40px; border-radius: 50%;
          background: linear-gradient(135deg, #6b46c1, #9333ea);
          display: flex; align-items: center; justify-content: center;
          color: white; font-weight: bold; font-size: 16px; flex-shrink: 0;
          border: 1px solid rgba(255,255,255,0.1);
        `;
        fallback.textContent = 'E';
        messageAvatar.parentNode.replaceChild(fallback, messageAvatar);
      };

      const messageContent = document.createElement('div');
      messageContent.className = 'message-content';
      messageContent.textContent = text;

      messageWrapper.appendChild(messageAvatar);
      messageWrapper.appendChild(messageContent);

      if (isReadingPhase) {
        chatMessages.appendChild(messageWrapper);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      } else {
        chatMessages.insertBefore(messageWrapper, chatMessages.firstChild);
        chatMessages.scrollTop = 0;
      }

      setTimeout(() => messageWrapper.classList.add('visible'), 50);
    }

    function addStandaloneButton(buttonText, callback) {
      const buttonWrapper = document.createElement('div');
      buttonWrapper.style.cssText = `
        display: flex; align-items: center; gap: 12px; margin: 20px 0; padding-left: 52px;
        opacity: 0; transform: translateY(20px); transition: opacity .5s ease, transform .5s ease;
      `;

      const button = document.createElement('button');
      button.className = 'chat-button';
      button.textContent = buttonText;
      button.onclick = callback;

      buttonWrapper.appendChild(button);

      if (isReadingPhase) {
        chatMessages.appendChild(buttonWrapper);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      } else {
        chatMessages.insertBefore(buttonWrapper, chatMessages.firstChild);
        chatMessages.scrollTop = 0;
      }

      setTimeout(() => {
        buttonWrapper.style.opacity = '1';
        buttonWrapper.style.transform = 'translateY(0)';
      }, 50);
    }

    function showPhase(phase) {
      shuffleContainer.classList.remove('active');
      loadingContainer.classList.remove('active');
      cardSelectionContainer.classList.remove('active');
      cardCarouselContainer.classList.remove('active');

      switch (phase) {
        case 'shuffle': shuffleContainer.classList.add('active'); break;
        case 'loading': loadingContainer.classList.add('active'); break;
        case 'selection': cardSelectionContainer.classList.add('active'); break;
        case 'carousel': cardCarouselContainer.classList.add('active'); break;
      }
    }

    async function startShuffle() {
      showPhase('loading');
      cardStack.style.transform = 'scale(1.1) rotate(5deg)';

      const loadingTitle = document.getElementById('loadingTitle');
      const loadingSubtitle = document.getElementById('loadingSubtitle');

      setTimeout(() => {
        loadingTitle.classList.add('hidden');
        loadingSubtitle.classList.add('visible');

        fetch('/api/spread')
          .then((res) => res.json())
          .then((data) => {
            spreadCards = data.spread;
            setTimeout(() => {
              cardStack.style.transform = 'scale(1) rotate(0deg)';
              showCardSelection();
            }, 1000);
          })
          .catch((error) => {
            console.error('Error fetching spread:', error);
            addMessage('Let me try shuffling those cards again...');
            setTimeout(startShuffle, 2000);
          });
      }, 4000);
    }

    function isMobileView() {
  return window.matchMedia('(max-width: 768px)').matches;
}

  function installChatSheetDrag() {
    if (!isMobileView()) return;

    const chat = document.querySelector('.chat-panel');
    if (!chat) return;

    // Create the handle once
    let handle = document.getElementById('chatDragHandle');
    if (!handle) {
      handle = document.createElement('div');
      handle.id = 'chatDragHandle';
      handle.innerHTML = '<div class="chevron"></div><div class="grab-pill"></div>';
      chat.prepend(handle);
    }

    // Enter sheet mode when drag starts
    function enterSheet() {
      if (!chat.classList.contains('sheet')) {
        chat.classList.add('sheet');
        // lock current height so we have a pixel base to drag from
        const h = chat.getBoundingClientRect().height || (window.innerHeight * 0.45);
        chat.style.setProperty('height', Math.max(220, Math.min(h, window.innerHeight)) + 'px', 'important');
      }
    }

    const safeTop = () => (parseFloat(getComputedStyle(document.body).paddingTop) || 0); // your fixed top bar space
    let startY, startH, minH, maxH;

    function onStart(e) {
      const t = (e.touches && e.touches[0]) || e;
      enterSheet();

      startY = t.clientY;
      startH = chat.getBoundingClientRect().height;

      // bounds: donâ€™t collapse too small; allow full height up to just under the top bar
      minH = Math.max(window.innerHeight * 0.30, 220);
      maxH = window.innerHeight - safeTop() - 4;

      document.addEventListener('touchmove', onMove, { passive: false });
      document.addEventListener('touchend', onEnd);
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onEnd);
    }

    function onMove(e) {
      const t = (e.touches && e.touches[0]) || e;
      const dy = t.clientY - startY;     // drag up => negative
      let newH = startH - dy;

      if (newH < minH) newH = minH;
      if (newH > maxH) newH = maxH;

      chat.style.setProperty('height', newH + 'px', 'important');

      if (e.cancelable) e.preventDefault();
    }

    function onEnd() {
      document.removeEventListener('touchmove', onMove);
      document.removeEventListener('touchend', onEnd);
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onEnd);
    }

    handle.addEventListener('touchstart', onStart, { passive: true });
    handle.addEventListener('mousedown', onStart);
  }

  // Call it when the DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(init, 500);
    installChatSheetDrag();
  });

  // Keep it mobile-only; clean up when moving to desktop
  window.addEventListener('resize', () => {
    if (isMobileView()) {
      installChatSheetDrag();
    } else {
      const chat = document.querySelector('.chat-panel');
      if (chat) {
        chat.classList.remove('sheet');
        chat.style.removeProperty('height');
      }
    }
  });

  window.addEventListener('orientationchange', () => setTimeout(() => {
    if (isMobileView()) installChatSheetDrag();
  }, 250));


/* Fit both card rows inside the visible deck area on mobile.
   Ensures row2 has some bottom padding while still fitting. */
function fitRowsForMobile() {
  if (!isMobileView()) return;

  const panel = document.getElementById('contentPanel');
  const sel   = document.getElementById('cardSelectionContainer');
  const row1  = document.getElementById('row1');
  const row2  = document.getElementById('row2');
  const progress = document.getElementById('selectionProgress');
  if (!panel || !sel || !row1 || !row2) return;

  // padding of the selection container itself
  const selStyles = getComputedStyle(sel);
  const padY = parseFloat(selStyles.paddingTop) + parseFloat(selStyles.paddingBottom);

  const progressH = progress ? progress.offsetHeight : 0;
  const gapBetweenRows = 20;       // your .card-row margin-bottom
  const bottomPadRow2  = 16;       // desired bottom padding inside row 2

  // figure out how far row1 cards lift upward (negative translateY)
  let maxUp = 0;
  row1.querySelectorAll('.card').forEach(c => {
    const lift = Number(c._lift || 0);     // negative means up
    if (lift < 0) maxUp = Math.max(maxUp, -lift);
  });
  const topPadRow1 = Math.ceil(maxUp) + 8; // a little extra breathing room

  // available height for the two rows *including* those paddings
  const available = panel.clientHeight - padY - progressH - gapBetweenRows - topPadRow1 - bottomPadRow2;

  let rowHeight = Math.floor(available / 2);
  rowHeight = Math.max(rowHeight, 130);    // don't go smaller than card height-ish

  // apply sizes + paddings
  row1.style.paddingTop = topPadRow1 + 'px';
  row1.style.height = rowHeight + 'px';

  row2.style.paddingBottom = bottomPadRow2 + 'px';
  row2.style.height = rowHeight + 'px';
}


  function installChatDrag() {
    if (!isMobileView()) return;

    const chat   = document.querySelector('.chat-panel');
    const deck   = document.getElementById('contentPanel');
    if (!chat || !deck) return;

    // Create the handle once
    let handle = document.getElementById('chatDragHandle');
    if (!handle) {
      handle = document.createElement('div');
      handle.id = 'chatDragHandle';
      handle.innerHTML = '<div class="chevron"></div><div class="grab-pill"></div>';
      chat.prepend(handle);
    }

    const progress = document.getElementById('selectionProgress');
    const sel = document.getElementById('cardSelectionContainer');
    const row1 = document.getElementById('row1');

    const bodyPadTop = () => parseFloat(getComputedStyle(document.body).paddingTop) || 0;
    const avail = () => window.innerHeight - bodyPadTop(); // total space for deck+chat

    function computeMinDeck() {
      if (!sel || !row1) return 320; // safe default
      const s = getComputedStyle(sel);
      const padY = parseFloat(s.paddingTop) + parseFloat(s.paddingBottom);
      const gap = 20, bottomPadRow2 = 16;
      const progressH = progress ? progress.offsetHeight : 0;

      // How much row1 lifts upward (negative translateY)
      let maxUp = 0;
      row1.querySelectorAll('.card').forEach(c => {
        const lift = Number(c._lift || 0);
        if (lift < 0) maxUp = Math.max(maxUp, -lift);
      });
      const topPadRow1 = Math.ceil(maxUp) + 8;

      // 2 rows * ~130px each + paddings/gap/progress text
      return (2 * 130) + topPadRow1 + bottomPadRow2 + gap + progressH + padY;
    }

    let startY, startChatH, minDeckCached;

    function onStart(e) {
      const t = (e.touches && e.touches[0]) || e;
      startY = t.clientY;
      startChatH = chat.getBoundingClientRect().height;
      minDeckCached = computeMinDeck();

      document.addEventListener('touchmove', onMove, { passive: false });
      document.addEventListener('touchend', onEnd);
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onEnd);
    }

    function onMove(e) {
      const t = (e.touches && e.touches[0]) || e;
      const dy = t.clientY - startY;          // up = negative
      const total = avail();

      // Grow chat when dragging up; clamp so deck never gets too small
      let newChat = startChatH - dy;
      const minChat = Math.max(total * 0.30, 200);
      const maxChat = Math.max(total - minDeckCached, minChat + 1);

      if (newChat < minChat) newChat = minChat;
      if (newChat > maxChat) newChat = maxChat;

      const newDeck = total - newChat;

      // Override mobile CSS (which uses !important) with inline !important
      chat.style.setProperty('height', newChat + 'px', 'important');
      deck.style.setProperty('height', newDeck + 'px', 'important');

      // Refit cards inside the new deck height
      fitRowsForMobile();

      if (e.cancelable) e.preventDefault();
    }

    function onEnd() {
      document.removeEventListener('touchmove', onMove);
      document.removeEventListener('touchend', onEnd);
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onEnd);
    }

    handle.addEventListener('touchstart', onStart, { passive: true });
    handle.addEventListener('mousedown', onStart);
  }

  // After your existing listeners:
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(init, 500);
    // install the handle after DOM is ready
    installChatDrag();
  });

  window.addEventListener('resize', () => {
    if (isMobileView()) installChatDrag();   // re-ensure handle exists after resizes
    fitRowsForMobile();
  });
  window.addEventListener('orientationchange', () => setTimeout(() => {
    if (isMobileView()) installChatDrag();
    fitRowsForMobile();
  }, 250));

    function showCardSelection() {
      addMessage('Select 6 cards that call to you.');
      showPhase('selection');
      setupCardSelection();
    }


    function setupCardSelection() {
      const row1 = document.getElementById('row1');
      const row2 = document.getElementById('row2');
      row1.innerHTML = '';
      row2.innerHTML = '';

      const halfway = Math.ceil(spreadCards.length / 2);
      const firstHalf = spreadCards.slice(0, halfway);
      const secondHalf = spreadCards.slice(halfway);

      fanCards(row1, firstHalf, true);
      fanCards(row2, secondHalf, false);
      requestAnimationFrame(() => fitRowsForMobile());

    }

    function fanCards(container, cards, upwardCurve) {
      const total = cards.length;
      const isMobile = window.matchMedia('(max-width: 768px)').matches;
      const ANGLE_SPREAD = isMobile ? 36 : 50;
      const OFFSET_STEP = isMobile ? 32 : 46;
      const LIFT_FACTOR = isMobile ? 6 : 8;

      const angleStep = total > 1 ? ANGLE_SPREAD / (total - 1) : 0;
      const startAngle = -ANGLE_SPREAD / 2;

      cards.forEach((card, i) => {
        const el = document.createElement('div');
        el.className = 'card';

        const inner = document.createElement('div');
        inner.className = 'card-inner';

        const back = document.createElement('div');
        back.className = 'card-face card-back';

        const front = document.createElement('div');
        front.className = 'card-face card-front';
        front.style.setProperty('--card-image', `url('${card.image}')`);

        inner.appendChild(back); inner.appendChild(front); el.appendChild(inner);

        const angle = startAngle + i * angleStep;
        const centerIndex = (total - 1) / 2;
        const offset = (i - centerIndex) * OFFSET_STEP;
        const lift = upwardCurve ? -Math.abs(i - centerIndex) * LIFT_FACTOR : 0;

        el.style.transform = `translate(${offset}px, ${lift}px) rotate(${angle}deg)`;
        el._offset = offset; el._lift = lift; el._angle = angle;

        el.addEventListener('click', () => selectCard(el, card));
        container.appendChild(el);
      });
    }

    function selectCard(el, card) {
      if (el.classList.contains('selected')) return;
      if (selectedCards.length >= 6) { addMessage("You can only select 6 cards. If you'd like to change your selection, refresh and start over."); return; }

      el.classList.add('selected');
      selectedCards.push(card);
      el.style.transform = `translate(${el._offset}px, ${el._lift - 15}px) rotate(${el._angle}deg)`;
      updateSelectionProgress();

      if (selectedCards.length === 6) setTimeout(showPopup, 500);
    }

    function updateSelectionProgress() {
      document.getElementById('selectionProgress').textContent = `Select 6 cards (${selectedCards.length} selected)`;
    }

    function showPopup() { popupOverlay.classList.add('active'); setTimeout(generateReading, 1500); }
    function hidePopup() { popupOverlay.classList.remove('active'); }

    async function generateReading() {
      try {
        const response = await fetch('/api/reading', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ question: userQuestion, selectedCards })
        });
        const data = await response.json();

        setTimeout(() => {
          hidePopup();
          showCardCarousel();
          setTimeout(() => { deliverReading(data.answer); }, 800);
        }, 2000);
      } catch (e) {
        console.error('Error generating reading:', e);
        hidePopup();
        addMessage("I'm having trouble connecting with the cards right now. Please try again in a moment.");
      }
    }

    function goNext(){ if(!selectedCards.length) return; currentCardIndex=(currentCardIndex+1)%selectedCards.length; updateCarousel(); }
    function goPrev(){ if(!selectedCards.length) return; currentCardIndex=(currentCardIndex-1+selectedCards.length)%selectedCards.length; updateCarousel(); }
    function handleCarouselKeys(e){ if(!cardCarouselContainer.classList.contains('active')) return; if(e.key==='ArrowRight') goNext(); if(e.key==='ArrowLeft') goPrev(); }
    function enableSwipe(el){ let startX=null; el.addEventListener('touchstart', e=>{startX=e.changedTouches[0].clientX;},{passive:true}); el.addEventListener('touchend', e=>{ if(startX==null) return; const dx=e.changedTouches[0].clientX-startX; startX=null; if(Math.abs(dx)>40){ dx<0?goNext():goPrev(); } }, {passive:true}); }

    function showCardCarousel() {
      showPhase('carousel');
      setupCarousel();
      document.querySelector('.carousel-arrow.prev').onclick = goPrev;
      document.querySelector('.carousel-arrow.next').onclick = goNext;
      document.addEventListener('keydown', handleCarouselKeys);
      enableSwipe(document.getElementById('carouselCards'));
    }

    function setupCarousel() {
      const cardsWrap = document.getElementById('carouselCards');
      const nav = document.getElementById('carouselNav');
      cardsWrap.innerHTML = '';
      nav.innerHTML = '';

      selectedCards.forEach((card, index) => {
        const cardEl = document.createElement('div');
        cardEl.className = 'carousel-card';
        cardEl.style.backgroundImage = `url('${card.image}')`;
        cardEl.addEventListener('click', () => goToCard(index));
        cardsWrap.appendChild(cardEl);

        const dot = document.createElement('div');
        dot.className = 'nav-dot';
        dot.addEventListener('click', () => goToCard(index));
        nav.appendChild(dot);
      });

      updateCarousel();
    }

    function goToCard(i){ currentCardIndex=i; updateCarousel(); }

    function updateCarousel() {
      const cards = document.querySelectorAll('.carousel-card');
      const dots = document.querySelectorAll('.nav-dot');
      cards.forEach((card, i) => {
        card.classList.remove('active','prev','next','hidden');
        if (i===currentCardIndex) card.classList.add('active');
        else if (i===(currentCardIndex-1+cards.length)%cards.length) card.classList.add('prev');
        else if (i===(currentCardIndex+1)%cards.length) card.classList.add('next');
        else card.classList.add('hidden');
      });
      dots.forEach((dot, i) => dot.classList.toggle('active', i===currentCardIndex));
    }

// --- Try to derive a human name if the API didn't include one ---
function deriveNameFromImage(src = '') {
  try {
    const parts = src.split('/');
    // Best-guess slug (e.g., "nine-of-pentacles" or filename without extension)
    const slug = parts.find(p => /-of-|^the-|wands|cups|swords|pentacles|major|minor/i.test(p))
              || parts[parts.length - 1].replace(/\.[a-z]+$/i, '');
    const name = slug
      .replace(/-/g, ' ')
      .replace(/\b\w/g, c => c.toUpperCase())
      .trim();
    return name;
  } catch {
    return '';
  }
}

// --- Build regex patterns for each selected card name ---
function buildCardPatterns(cards) {
  const esc = s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  return cards
    .map(card => {
      const name = (card.name || deriveNameFromImage(card.image) || '').trim();
      if (!name) return null;
      return { name, re: new RegExp(`\\b${esc(name)}\\b`, 'i'), card };
    })
    .filter(Boolean);
}

// --- Append a small card thumb under the latest message (mobile only) ---
function addCardThumb(card, displayName) {
  if (!isMobileView()) return;
  const wrap = document.createElement('div');
  wrap.className = 'chat-card-thumb';
  wrap.innerHTML = `
    <div class="thumb-label">${displayName}</div>
    <img class="thumb-img" src="${card.image}" alt="${displayName}">
  `;
  chatMessages.appendChild(wrap);
  chatMessages.scrollTop = chatMessages.scrollHeight;
}


 function deliverReading(readingText) {
  isReadingPhase = true;

  // Build patterns once for the selected cards
  const patterns = buildCardPatterns(selectedCards);
  const shownThumbs = new Set(); // avoid duplicate thumbs

  const sentences = readingText.split(/(?<=[.!?])\s+/);
  const chunks = [];
  for (let i = 0; i < sentences.length; i += 3) {
    chunks.push(sentences.slice(i, i + 3).join(' '));
  }

  chunks.forEach((chunk, index) => {
    setTimeout(() => {
      // 1) Add the reading chunk message
      addMessage(chunk);

      // 2) On mobile, check if this chunk mentions any card(s)
      if (isMobileView() && patterns.length) {
        for (const { name, re, card } of patterns) {
          if (!shownThumbs.has(name) && re.test(chunk)) {
            addCardThumb(card, name);
            shownThumbs.add(name);
          }
        }
      }

      // 3) Wrap up
      if (index === chunks.length - 1) {
        setTimeout(() => {
          addStandaloneButton('New Reading', () => {
            window.location.href = '/question-screen.html';
          });
        }, 600);
      }
    }, index * 1200);
  });
}


    document.addEventListener('DOMContentLoaded', () => { setTimeout(init, 500); });
    window.addEventListener('resize', fitRowsForMobile);
    window.addEventListener('orientationchange', () => setTimeout(fitRowsForMobile, 250));
    window.addEventListener('load', fitRowsForMobile);
  </script>
</body>
</html>
